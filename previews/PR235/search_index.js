var documenterSearchIndex = {"docs":
[{"location":"References/#References","page":"References","title":"References","text":"","category":"section"},{"location":"References/","page":"References","title":"References","text":"","category":"page"},{"location":"simulation_setups/#Simulation-setups","page":"Simulation setups","title":"Simulation setups","text":"","category":"section"},{"location":"simulation_setups/#Box-model","page":"Simulation setups","title":"Box model","text":"","category":"section"},{"location":"simulation_setups/","page":"Simulation setups","title":"Simulation setups","text":"The Box Model simulation represents a zero-dimensional system that focuses on key processes within thermodynamics and collisional microphysics, designed to capture the dynamics of atmospheric particles under controlled conditions without spatial variation. This model is ideal for studying isolated processes in a simplified environment. It includes microphysical processes such as auto-conversion, which represents the transformation of cloud droplets into raindrops through collision and coalescence, and accretion, which models the capture of smaller cloud droplets by larger raindrops as they fall, crucial for understanding precipitation dynamics.","category":"page"},{"location":"simulation_setups/","page":"Simulation setups","title":"Simulation setups","text":"An example of running a box simulation is provided in the following file: test/experiments/box_driver/run_box_simulation.jl.","category":"page"},{"location":"simulation_setups/#KinematicDriver","page":"Simulation setups","title":"KinematicDriver","text":"","category":"section"},{"location":"simulation_setups/","page":"Simulation setups","title":"Simulation setups","text":"The KinematicDriver setup is based on the kinematic framework introduced by [1]: Vertical momentum flux is constant with height and varying in time. Density and temerature profiles are constant and defined by the initial   condition, which is unsaturated. As the simulation progresses in time moisture is transported upwards,   supersaturation grows in the upper part of the domain   and precipitation is formed. In the second part of the simulation the vertical momentum flux is switched off,   leaving only cloud microphysics tendencies acting to change   the model state. Below figure shows an example prescribed vertical momentum as a function of time.","category":"page"},{"location":"simulation_setups/","page":"Simulation setups","title":"Simulation setups","text":"using Plots\nimport KinematicDriver.K1DModel as K1D\n\nt_range = range(0, 15 * 60, length=100)\nw1 = 2.0\nt1 = 600.0\nplot(t_range / 60.0, [K1D.œÅw_helper(t, w1, t1) for t in t_range], linewidth=3, xlabel=\"t [min]\", ylabel=\"updraft momentum flux [m/s kg/m3]\")\nsavefig(\"prescribed_momentum_flux.svg\") #hide","category":"page"},{"location":"simulation_setups/","page":"Simulation setups","title":"Simulation setups","text":"(Image: )","category":"page"},{"location":"simulation_setups/","page":"Simulation setups","title":"Simulation setups","text":"An example of running a one-dimensional KiD simulation is provided in the following file: test/experiments/KiD_driver/KiD_driver.jl.","category":"page"},{"location":"simulation_setups/#Cloud-layer-simulations","page":"Simulation setups","title":"Cloud layer simulations","text":"","category":"section"},{"location":"simulation_setups/","page":"Simulation setups","title":"Simulation setups","text":"Cloud Layer Simulations employ a one-dimensional setup to explore atmospheric processes, facilitating a detailed examination of the evolution and interactions within a cloud layer. Initially, the simulation initializes the atmospheric column with a uniform gamma distribution, classifying particles into liquid and rain categories. As the simulation progresses, it incorporates thermodynamics, collisional microphysics, and sedimentation. These elements work together to model the complex behaviors of cloud formation and precipitation. By accounting for the vertical distribution and movement of particles, this simulation offers insights into how processes such as auto-conversion, accretion, and sedimentation influence cloud dynamics and precipitation patterns.","category":"page"},{"location":"simulation_setups/","page":"Simulation setups","title":"Simulation setups","text":"An example of running a cloud layer simulation is provided in the following file: test/experiments/KiD_col_sed_driver/run_KiD_col_sed_simulation.jl.","category":"page"},{"location":"simulation_setups/#Two-dimensional-system","page":"Simulation setups","title":"Two-dimensional system","text":"","category":"section"},{"location":"simulation_setups/","page":"Simulation setups","title":"Simulation setups","text":"The two-dimensional setup models the dynamics of an updraft and a downdraft in moist air, incorporating a range of atmospheric processes including thermodynamics, condensation, aerosol activation, collisional processes, and sedimentation of raindrops. These elements collectively simulate complex cloud and precipitation systems. The velocity profile, which varies across spatial dimensions x, z and over time t, is determined using the stream function psi, defined as follows:","category":"page"},{"location":"simulation_setups/","page":"Simulation setups","title":"Simulation setups","text":"beginalign\npsi(x z) = - (rho w)_0 fracWpi sinleft(fracpi zHright)cosleft(frac2pi xWright)\nendalign","category":"page"},{"location":"simulation_setups/","page":"Simulation setups","title":"Simulation setups","text":"In this equation, W denotes the width of the domain, H represents the height of the domain, and (rho w)_0 is the updraft amplitude, varying over time according to the following equation:","category":"page"},{"location":"simulation_setups/","page":"Simulation setups","title":"Simulation setups","text":"beginalign\n(rho w)_0 = begincases \n(rho w)_max sinleft(fracpi tt_1right)  textfor  t  t_1 \n0  textfor  t  t_1 \nendcases\nendalign","category":"page"},{"location":"simulation_setups/","page":"Simulation setups","title":"Simulation setups","text":"where (rho w)_max represents the maximum updraft amplitude. An example of running a two-dimensional simulation is provided in the following file: test/experiments/Ki2D_driver/run_kinematic2d_simulation.jl.","category":"page"},{"location":"simulation_setups/#Changes-to-CliMA-defaults","page":"Simulation setups","title":"Changes to CliMA defaults","text":"","category":"section"},{"location":"simulation_setups/","page":"Simulation setups","title":"Simulation setups","text":"One of the goals of KinematicDriver.jl   is to test against PySDM   and the particle-based implementation of the kinematic model available in   PySDM-examples. As a result, some CliMA constants were changed from their default values to better match PySDM:","category":"page"},{"location":"simulation_setups/","page":"Simulation setups","title":"Simulation setups","text":"symbol definition units default value new value\nMSLP Mean sea level pressure Pa 101325 10^5\ngrav Gravitational acceleration ms^2 981 980665\ngas_constant Universal gas constant JmolK 83144598 8314462618\nkappa_d Adiabatic exponent for dry air (2/7) - 028571428571 02855747338575384\ncp_v Isobaric specific heat of water vapor JkgK 1859 1850\nmolmass_dryair Molecular mass of dry air kgmol 002897 002896998\nmolmass_water Molecular mass of water kgmol 001801528 0018015\nqliqthreshold Cloud liquid water autoconversion threshold kgkg 00005 00001","category":"page"},{"location":"calibration_features/#Calibration-features","page":"Calibration features","title":"Calibration features","text":"","category":"section"},{"location":"calibration_features/","page":"Calibration features","title":"Calibration features","text":"KinematicDriver.jl(KiD) provides tools for calibrating microphysical parameters, using one-dimensional simulations and comparing results with reference particle-based simulations. This process aids in fine-tuning the simulation models to better match detailed simulations of particle-based methods, enhancing the accuracy and reliability of simulation outcomes. The main particle-based method that is employed as reference for the calibrations is PySDM. This Python package is designed for simulating the dynamics of population of particles and features a high-performance implementation of Super-Droplet Method (SDM) Monte-Carlo algorithm for representing collisional growth. ","category":"page"},{"location":"calibration_features/","page":"Calibration features","title":"Calibration features","text":"To perform the calibrations against PySDM results, it is crucial to define the calibration setup and its configuration file accordingly, and to change the CliMA constants where needed. ","category":"page"},{"location":"calibration_features/#Calibration-Methods","page":"Calibration features","title":"Calibration Methods","text":"","category":"section"},{"location":"calibration_features/","page":"Calibration features","title":"Calibration features","text":"KiD supports several calibration methods, including Ensemble Kalman Inversion (EKI) [2], Unscented Kalman Inversion (UKI) [3], and Optim.jl tools.","category":"page"},{"location":"calibration_features/","page":"Calibration features","title":"Calibration features","text":"Both EKI and UKI are methods that are implemented in the EnsembleKalmanProcesses.jl library. They are derivative-free Bayesian optimization techniques which are based on ensemble Kalman Filters. Using these methods, we can fit the parameters found in computationally expensive black-box codes, without having to compute derivatives and adjoints. This allows efficient calibration while quantifying parameter uncertainty and model errors. Specifically:","category":"page"},{"location":"calibration_features/","page":"Calibration features","title":"Calibration features","text":"Ensemble Kalman Inversion uses an ensemble of model states to update the estimates of both the state and the parameters, and it is particularly robust against model errors.\nUnscented Kalman Inversion is valuable to explore parameter uncertainties and their correlations.","category":"page"},{"location":"calibration_features/","page":"Calibration features","title":"Calibration features","text":"Additionally, for those who prefer straightforward optimization approaches, we integrate optimization tools from Optim.jl. ","category":"page"},{"location":"calibration_features/#Configuration-File","page":"Calibration features","title":"Configuration File","text":"","category":"section"},{"location":"calibration_features/","page":"Calibration features","title":"Calibration features","text":"To use the calibration tools, it is crucial to provide a configuration file detailing all the elements needed for the calibration process.  The user must define:","category":"page"},{"location":"calibration_features/","page":"Calibration features","title":"Calibration features","text":"Priors: the prior distributions of the parameters that need to be calibrated. The user must construct a dictionary in which each prior is specified by a ParameterDistribution object (see parameter_distributions). For each parameter, the definition of the prior requires the name of the parameter, the approximate mean and standard deviation of its distribution, and the interval in which it can take values.\nObservations: The reference data against which simulations are compared. To do this, you can select the source of data (\"perfect_model\" or \"file\"), as well as the data names, data type, and the characteristics of the validation set for the calibrations.\nCalibration Process: The methods and approaches used for calibration. In this part, the user must select the calibration method, as well as the variables that are needed for the process (e.g., number of iterations, batch size, random seed, etc.).\nModel Parameters setup: Details about the parameters that affect the model's behavior, such as the model name, the characteristics of the grid, the aerosol initial distribution, the precipitation choice, etc.\nStatistics: The statistical methods that can be applied on the data and simulation results to compare them.","category":"page"},{"location":"calibration_features/#How-to-run-a-calibration","page":"Calibration features","title":"How to run a calibration","text":"","category":"section"},{"location":"calibration_features/","page":"Calibration features","title":"Calibration features","text":"To be able to run a calibration, you need to import the /KinematicDriver/CalibrateCMP module and include the configuration file associated with the calibrtion that you want to perform. ","category":"page"},{"location":"calibration_features/#Example","page":"Calibration features","title":"Example","text":"","category":"section"},{"location":"calibration_features/","page":"Calibration features","title":"Calibration features","text":"To better understand how to build the configuration file and run calibrations in KiD, you can find a 1-dimensional calibration example in the test/experiments/calibrations folder.  In this example, we calibrate the 1-moment microphysics bulk scheme in the perfect-model mode (by using data produced by the same method); specifically, the products that we consider are rain water mixing ratio and cloud water mixing ratio. The parameters that are calibrated are chi_v, and chi_a, two parameters that appear in the terminal velocity (v_term(r)) and rain cross-section (a(r)) formulas of the bulk scheme:","category":"page"},{"location":"calibration_features/","page":"Calibration features","title":"Calibration features","text":"a(r) = chi_a  a_0 left(fracrr_0right)^a_e + Delta_a","category":"page"},{"location":"calibration_features/","page":"Calibration features","title":"Calibration features","text":"v_term(r) = chi_v  v_0 left(fracrr_0right)^v_e + Delta_v","category":"page"},{"location":"calibration_features/","page":"Calibration features","title":"Calibration features","text":"Inside the calibration example, there are examples of the config.jl file, the run_calibration.jl file, and run_model.jl.","category":"page"},{"location":"calibration_features/","page":"Calibration features","title":"Calibration features","text":"In config.jl, we define the function get_config(), which creates the configuration dictionary. The keys of this dictionary are associated with all the elements that are needed for the calibration process, and they are retrieved using the following functions:","category":"page"},{"location":"calibration_features/","page":"Calibration features","title":"Calibration features","text":"get_prior_config(): Sets up the priors' configuration.\nget_observations_config(): Specifies the reference data.  \nget_process_config(): Defines the method for the calibration and the associated parameters.\nget_model_config(): Defines the model setup.\nget_stats_config(): Specifies the statistical methods used on the reference data and simulation results.","category":"page"},{"location":"calibration_features/","page":"Calibration features","title":"Calibration features","text":"After creating the configuration file, running the calibrations can be performed by using the run_calibration.jl file.  By importing the /KinematicDriver/src/CalibrateCMP module and including the configuration file, you can use the appropriate functions to construct the priors and get the reference observations. Depending on the calibration method that you choose, the calibrate() and get_results() functions allow you to perform the calibration steps and obtain the final set of optimal parameters.  When choosing the EKI or UKI methods, calibrate() outputs the posterior ensemble and the optimal parameters, that are computed based on the final ensemble of parameters (statistical mean). To obtain the optimal values in the constrained space as well as the covariance connected to the distribution that describes the solution of the inversion problem, you can simply call the get_results() function.","category":"page"},{"location":"calibration_features/","page":"Calibration features","title":"Calibration features","text":"in the following animation, you can see the output of run_calibration.jl, which illustrates the convergence of the parameter ensemble towards the posterior by using UKI:","category":"page"},{"location":"calibration_features/","page":"Calibration features","title":"Calibration features","text":"(Image: Ensemble convergence)","category":"page"},{"location":"calibration_features/","page":"Calibration features","title":"Calibration features","text":"Finally, by running the run_model.jl, you can see contour plots of the cloud water mixing ratio and rain water mixing ratio  that are obtained with KiD, and compare them with the reference data.","category":"page"},{"location":"#KinematicDriver.jl","page":"Home","title":"KinematicDriver.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"KinematicDriver.jl (KiD) is a Julia package that provides tools for prescribed flow simulations, and it is used for testing and calibrating microphysics schemes. It serves as a simple substitute for a dynamical core, acting as a driver for bulk cloud microphysics parameterization schemes. KiD is designed to facilitate the assessment of microphysical parameterizations. By prescribing both the momentum and temperature fields, it prevents any feedback between the dynamics and the microphysics, ensuring that variations in results can only be attributed to microphysics parameterizations. An important characteristic of the KiD model is its computational efficiency, which is crucial for efficient parameter calibrations. The prescribed flow is described by the equation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginalign\n    rho w(zt) = (rho w)_0 sinleft(fracpi tt_1right)quad 0tt_1\nendalign","category":"page"},{"location":"","page":"Home","title":"Home","text":"where t_1 defines the upper time limit of the updraft, rho is the dry air density, w represents the vertical velocity component and (rho w)_0 denotes the maximum updraft momentum.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Inside KinematicDriver.jl we use ClimaCore.jl operators and CloudMicrophysics.jl tendencies to create the numerical problem that is then solved using OrdinaryDiffEq.jl.","category":"page"},{"location":"#Documentation-outline","page":"Home","title":"Documentation outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Simulation Setups: Introduces the physical systems that can be simulated using this package.\nCalibration Features: Describes the tools available for calibrating microphysical parameters, based on comparing simulations provided in this package with reference detailed simulations.\nReferences: Provides a list of publications that support the tools implemented in this package.","category":"page"},{"location":"#Contributing-and-license","page":"Home","title":"Contributing and license","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"KinematicDriver.jl is developed by the Climate Modeling Alliance and is released under the Apache License Version 2.0. Please open an issue or reach out to us if you have any questions or comments.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Clima logo)","category":"page"}]
}
