<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Calibration features · KinematicDriver.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="KinematicDriver.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">KinematicDriver.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../simulation_setups/">Simulation setups</a></li><li class="is-active"><a class="tocitem" href>Calibration features</a><ul class="internal"><li><a class="tocitem" href="#Calibration-Methods"><span>Calibration Methods</span></a></li><li><a class="tocitem" href="#Configuration-File"><span>Configuration File</span></a></li><li><a class="tocitem" href="#How-to-run-a-calibration"><span>How to run a calibration</span></a></li><li><a class="tocitem" href="#Example"><span>Example</span></a></li></ul></li><li><a class="tocitem" href="../References/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Calibration features</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Calibration features</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CliMA/KinematicDriver.jl/blob/main/docs/src/calibration_features.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Calibration-features"><a class="docs-heading-anchor" href="#Calibration-features">Calibration features</a><a id="Calibration-features-1"></a><a class="docs-heading-anchor-permalink" href="#Calibration-features" title="Permalink"></a></h1><p><code>KinematicDriver.jl</code>(KiD) provides tools for calibrating microphysical parameters, using one-dimensional simulations and comparing results with reference particle-based simulations. This process aids in fine-tuning the simulation models to better match detailed simulations of particle-based methods, enhancing the accuracy and reliability of simulation outcomes. The main particle-based method that is employed as reference for the calibrations is <a href="https://github.com/atmos-cloud-sim-uj/PySDM">PySDM</a>. This Python package is designed for simulating the dynamics of population of particles and features a high-performance implementation of Super-Droplet Method (SDM) Monte-Carlo algorithm for representing collisional growth. </p><p>To perform the calibrations against PySDM results, it is crucial to define the calibration setup and its configuration file accordingly, and to change the CliMA constants where needed. </p><h2 id="Calibration-Methods"><a class="docs-heading-anchor" href="#Calibration-Methods">Calibration Methods</a><a id="Calibration-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Calibration-Methods" title="Permalink"></a></h2><p>KiD supports several calibration methods, including <strong>Ensemble Kalman Inversion (EKI)</strong> <a href="../References/#EKI">[2]</a>, <strong>Unscented Kalman Inversion (UKI)</strong> <a href="../References/#UKI">[3]</a>, and <code>Optim.jl</code> tools.</p><p>Both <strong>EKI</strong> and <strong>UKI</strong> are methods that are implemented in the <a href="https://clima.github.io/EnsembleKalmanProcesses.jl/dev/"><code>EnsembleKalmanProcesses.jl</code></a> library. They are derivative-free Bayesian optimization techniques which are based on ensemble Kalman Filters. Using these methods, we can fit the parameters found in computationally expensive black-box codes, without having to compute derivatives and adjoints. This allows efficient calibration while quantifying parameter uncertainty and model errors. Specifically:</p><ul><li><strong>Ensemble Kalman Inversion</strong> uses an ensemble of model states to update the estimates of both the state and the parameters, and it is particularly robust against model errors.</li><li><strong>Unscented Kalman Inversion</strong> is valuable to explore parameter uncertainties and their correlations.</li></ul><p>Additionally, for those who prefer straightforward optimization approaches, we integrate optimization tools from <a href="https://julianlsolvers.github.io/Optim.jl/stable/"><code>Optim.jl</code></a>. </p><h2 id="Configuration-File"><a class="docs-heading-anchor" href="#Configuration-File">Configuration File</a><a id="Configuration-File-1"></a><a class="docs-heading-anchor-permalink" href="#Configuration-File" title="Permalink"></a></h2><p>To use the calibration tools, it is crucial to provide a configuration file detailing all the elements needed for the calibration process.  The user must define:</p><ul><li><strong>Priors</strong>: the prior distributions of the parameters that need to be calibrated. The user must construct a dictionary in which each prior is specified by a <code>ParameterDistribution</code> object (see <a href="https://clima.github.io/EnsembleKalmanProcesses.jl/dev/parameter_distributions/">parameter_distributions</a>). For each parameter, the definition of the prior requires the name of the parameter, the approximate mean and standard deviation of its distribution, and the interval in which it can take values.</li><li><strong>Observations</strong>: The reference data against which simulations are compared. To do this, you can select the source of data (&quot;perfect_model&quot; or &quot;file&quot;), as well as the data names, data type, and the characteristics of the validation set for the calibrations.</li><li><strong>Calibration Process</strong>: The methods and approaches used for calibration. In this part, the user must select the calibration method, as well as the variables that are needed for the process (e.g., number of iterations, batch size, random seed, etc.).</li><li><strong>Model Parameters setup</strong>: Details about the parameters that affect the model&#39;s behavior, such as the model name, the characteristics of the grid, the aerosol initial distribution, the precipitation choice, etc.</li><li><strong>Statistics</strong>: The statistical methods that can be applied on the data and simulation results to compare them.</li></ul><h2 id="How-to-run-a-calibration"><a class="docs-heading-anchor" href="#How-to-run-a-calibration">How to run a calibration</a><a id="How-to-run-a-calibration-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-run-a-calibration" title="Permalink"></a></h2><p>To be able to run a calibration, you need to import the <code>/KinematicDriver/CalibrateCMP</code> module and include the configuration file associated with the calibrtion that you want to perform. </p><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>To better understand how to build the configuration file and run calibrations in KiD, you can find a 1-dimensional calibration example in the <code>test/experiments/calibrations</code> folder.  In this example, we calibrate the <a href="https://clima.github.io/CloudMicrophysics.jl/dev/Microphysics1M/">1-moment microphysics bulk scheme</a> in the perfect-model mode (by using data produced by the same method); specifically, the products that we consider are rain water mixing ratio and cloud water mixing ratio. The parameters that are calibrated are <span>$\chi_v$</span>, and <span>$\chi_a$</span>, two parameters that appear in the terminal velocity (<span>$v_{term}(r)$</span>) and rain cross-section (<span>$a(r)$</span>) formulas of the bulk scheme:</p><p class="math-container">\[a(r) = \chi_a \, a_0 \left(\frac{r}{r_0}\right)^{a_e + \Delta_a}\]</p><p class="math-container">\[v_{term}(r) = \chi_v \, v_0 \left(\frac{r}{r_0}\right)^{v_e + \Delta_v}.\]</p><p>Inside the calibration example, there are examples of the <code>config.jl</code> file, the <code>run_calibration.jl</code> file, and <code>run_model.jl</code>.</p><p>In <code>config.jl</code>, we define the function <code>get_config()</code>, which creates the configuration dictionary. The keys of this dictionary are associated with all the elements that are needed for the calibration process, and they are retrieved using the following functions:</p><ul><li><code>get_prior_config()</code>: Sets up the priors&#39; configuration.</li><li><code>get_observations_config()</code>: Specifies the reference data.  </li><li><code>get_process_config()</code>: Defines the method for the calibration and the associated parameters.</li><li><code>get_model_config()</code>: Defines the model setup.</li><li><code>get_stats_config()</code>: Specifies the statistical methods used on the reference data and simulation results.</li></ul><p>After creating the configuration file, running the calibrations can be performed by using the <code>run_calibration.jl</code> file.  By importing the <code>/KinematicDriver/src/CalibrateCMP</code> module and including the configuration file, you can use the appropriate functions to construct the priors and get the reference observations. Depending on the calibration method that you choose, the <code>calibrate()</code> and <code>get_results()</code> functions allow you to perform the calibration steps and obtain the final set of optimal parameters.  When choosing the EKI or UKI methods, <code>calibrate()</code> outputs the posterior ensemble and the optimal parameters, that are computed based on the final ensemble of parameters (statistical mean). To obtain the optimal values in the constrained space as well as the covariance connected to the distribution that describes the solution of the inversion problem, you can simply call the <code>get_results()</code> function.</p><p>in the following animation, you can see the output of <code>run_calibration.jl</code>, which illustrates the convergence of the parameter ensemble towards the posterior by using UKI:</p><p><img src="../assets/ensemble_convergence.gif" alt="Ensemble convergence"/></p><p>Finally, by running the <code>run_model.jl</code>, you can see contour plots of the cloud water mixing ratio and rain water mixing ratio  that are obtained with KiD, and compare them with the reference data.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../simulation_setups/">« Simulation setups</a><a class="docs-footer-nextpage" href="../References/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 31 May 2024 17:33">Friday 31 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
